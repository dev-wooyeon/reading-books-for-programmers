## 요약 (자본이 넉넉한 상태에서 가능할 것 같음!)

- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계칭은 샤딩을 통해 규모를 확장할 것
- 각 계층은 독립적으로 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고 자동화 도구들을 활용할 것

## 단일 서버 요청이 처리되는 과정

- 사용자 요청 전송 (Request)
    - HTTP Method (GET, POST, PUT, DELETE, OPTION)
    - URL
    - 헤더
    - 쿠키
    - Body
- 네트워크 계층을 통한 요청 전달
    - DNS - 도메인 이름을 IP 주소로 변환, 사용자가 IP주소 보다 비교적 기억하기 쉬운 이름을 제공
    - IP주소 확인 후 TCP/IP 프로토콜을 통해 요청 데이터가 서버에 전달
    - http일 경우 80번 포트, https일 경우 433번 포트
- 요청 수신
    - 웹 서버 WAS가 요청을 수신
    - 요청 URL에 따라 적절한 리소스를 찾고 라우팅
- 요청 처리
    - 요청 처리를 위해 서버는 비지니스 로직을 실행 (동적 요청일 때)
- Optional(DB 접근)
    - 비지니스 로직 실행할 때 필요에 따라 DB 조회 등 SQL을 통신
- 응답 전송
    - 요청 처리를 마치면 결과를 반환
    - 네트워크 처리에 대한 응답 코드 + Optional(body)

## 데이터베이스

- RDBMS
    - **MySQL**, Oracle , PostgreSQL 등
- NoSQL
    - **MongoDB**, DynamoDB 등

## 로드밸런서

서버에 요청의 한계가오면 일반적으로 서버를 늘려 분산 처리를 하려고 한다면 필요하다.

로드밸런서는 적절하게 트래픽을 분산하는 역할을 한다.

자 그럼 이제 웹 계층은 괜찮아 보인다. 데이터 계층은?

Master - Slave 구조로 다중화하여 처리하면 어느정도 해결할 수 있다.

## 캐시

값비싼 연산 결과를 주로 캐시에 담아 메모리에서 관리하고 보다 빨리처리 될 수 있도록 한다.

값비싼 연산 결과의 기준은 시간과 자원이 많이 드는 작업이라고 생각했고 해결 방법으로는 여러 방법이 있겠지만 생각해봤을 때 가장 효과적이였던 방법은 사용자가 요청하는 API의 경우 Latency를 측정하고 만약 2초를 넘어간다면 쿼리를 우선적으로 의심하여 조회 쿼리를 캐시처리를 하는것이 효과적이였던 것 같다.

이래도 안된다면 메모리 사용량, CPU 사용량 측정을 해볼 것 같다.

- 캐시 서버는 한대만 두는 경우 다운되었을 때 어떻게 대처할 수 있을까?

> 이럴 경우를 대비해서 원본 데이터 소스에서 조회할 수 있도록 구현하는 것이 비용적인 측면에서 다중화하는 것보다 나아보인다.
> 

 

## CDN

동작 방법

<img width="486" height="210" alt="image" src="https://github.com/user-attachments/assets/8348ee09-d07e-47a8-b019-bedf63ec992e" />


## 무상태(stateless) 웹 계층

[무상태 웹계층이 상태를 가지고 있는 웹계층보다 대규모 설계할 때 채택되는 이유가 뭐야?](https://www.notion.so/c3b830fc97d64b32b28c44dc063f3d68?pvs=21)

왜 써야하는가? 스케일 아웃하기 좋거든. 수평적으로 확장 서버를 늘리는 것을 의미

로그인 정보등의 상태를 가지고 있는 서버를 따로 만들고 상태를 가지고 있지 않은 어플리케이션을 구현했을 때 무상태 어플리케이션을 스케일 아웃하는 경우 무상태 웹계층이라고 볼 수 있어?

[만약에 유저수가 너무 많아서 무상태 어플리케이션을 8대를 운영하고 1대의 상태를 관리하는 어플리케이션을 운영한다면 어떤 문제가 생길 수 있고 이것을 해결하는 방법에는 뭐가 있을까?](https://www.notion.so/8-1-afc0b544a9ac42fba35c56cba9db3095?pvs=21)

## 메시지 큐

서버간 결합이 느슨해져서 안정적이고 유연한 애플리케이션을 구성하기 좋다.

Apache Kafka, Rabbit MQ, [BlazingMQ](https://bloomberg.github.io/blazingmq/) 등이 있다.

여까지 반영한 설계안

<img width="585" height="633" alt="image" src="https://github.com/user-attachments/assets/b1e5810a-4d0d-4890-b9d9-eeba2272eb8b" />

## 데이터베이스 수평적 확장

<img width="525" height="323" alt="image" src="https://github.com/user-attachments/assets/f7687adf-e660-4fd1-b46e-426bc4c1c1b5" />

샤딩이라고 부르는 이 기술은 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 말한다.

일반적으로 아래 그림처럼 id % 4를 해시 함수로 사용하여 결과에 따라 데이터가 보관되는 샤드를 정한다.

<img width="319" height="193" alt="image" src="https://github.com/user-attachments/assets/94bdcda8-a694-4a86-84c7-d10088da539c" />

🤔 언제 수직적 확장을해야할까?

- 단일 노드의 성능(처리 속도, 메모리, CPU 사용률 등)이 병목이라면 우선적으로 고려해야할 듯.
- 상태가 있는 경우(추가적인 상태 공유나 데이터 동기화하는 것들이 필요)
- 비싸더라도 확실한 성능을 기대할 때?
- 가장 좋은건 AWS에서 제공하는 수직적 규모 확장을 끝까지 하고 규모를 늘리는 방법 ㅋㅋ? 너무 무식한가

GPT 한테 선택기준을 물어보니 이런 표를 알려주었다. 참고해서 생각해보면 좋을 것 같다.

### 선택 기준 정리

| **기준** | **수직적 확장** | **수평적 확장** |
| --- | --- | --- |
| **초기 비용** | 낮음 | 높음 |
| **확장성** | 제한적 (하드웨어 한계 있음) | 뛰어남 (필요에 따라 서버 추가 가능) |
| **운영 복잡성** | 낮음 | 높음 |
| **성능 요구** | 단일 서버 성능이 중요할 때 | 대규모 동시 요청 처리 시 |
| **데이터 일관성** | 단순 관리 | 분산 데이터베이스 동기화 필요 |
| **장기적 비용 효율성** | 낮음 (고성능 서버 비용이 높음) | 높음 |
| **다운타임** | 하드웨어 업그레이드 시 발생 가능 | 없음 (서버 추가 및 제거 시에도 가능) |
