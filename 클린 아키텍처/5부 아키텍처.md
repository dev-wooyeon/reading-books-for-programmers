# 5부 15장. 아키텍처란?

> 시스템을 구축했던 사람들이 만들어낸 시스템의 형태

그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.
그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포,운영, 유지보수 되도록 만들어진다.

> 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 함

## 개발
시스템 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 해야한다.

## 배포
소프트웨어 아키텍처는 쉽게 배포할 수 있도록 만들어야 한다. 배포 비용이 높아질 수록 시스템의 유용성이 떨어진다고 생각하자.

## 운영
시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 first-class 엔티티로 만들고, 개발자들에게 이들을 주요 목표로 인식 되도록 해야한다.

→이를 통해 시스템 이해가 쉬워진다.

## 유지보수
유지보수는 가장 비용이 많이 드는 부분이지만, 아키텍처를 신중하게 만들면 이 비용을 줄일 수 있다.

탐사와 그것으로 인한 위험요소에 대한 비용이 제일 많이 들기 때문에, 더욱 신경써야한다.

탐사 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 어디를 고쳐야 할지, 어떤 전략을 쓰는게 최적일지 판단하는 비용

>*탐사란?
> 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트 웨어를 파해쳐서 어디를 고치는게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용

## 선택사항 열어두기
소프트웨어를 부드럽게 유지하려면, 중요하지 않은 세부사항을 가능한 많이, 그리고 오랫동안 열어두는 것이다.

정책 : 시스템의 진정한 가치로서, 모든 업무 규칙과 업무 절차를 구체화한다.
세부사항 : 클라이언트, 프로그래머 등이 정책과 소통할 때, 필요한 요소지만, 정책이 가진 행위에는 영향을 미치지 않음을 유의해야한다.
→ 좋은 아키텍트는 결정되지 않는 것들의 수를 최대화 해야한다.

## 장치 독립성
장치독립적인 것을 중요하다. 장치 종속적일 경우 장치마다 해당 코드를 생성해야하기 때문이다.

오늘날 운영체제는 장치 독립적이다.

## 광고 우편
저자의 경험이 담겨있다.

정책을 세부사항으로 분리하고, 어떤장치를 사용할 지에 대한 결정을 최대한 미뤘다는 내용이 담겨있다.

## 물리적 주소할당
정책을 물리적 구조로 부터 독립시킴으로써 애플리케이션과 하드웨어를 분리할 수 있었다.

## 결론
좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.

---

# 5부 16장. 독립성

## 좋은 아키텍처

- 시스템의 유즈케이스 지원
- 시스템의 운영이 고려된 아키텍처
- 시스템의 독립적 개발
- 시스템의 즉각적인 배포

## 유즈케이스

- 시스템이 지닌 의도를 아키텍처 수준에서 알아 볼 수 있도록 만드는 것이다.
    - 🧐 MVC Model2 Architecture의 Controller 역할?

🧐 일급 요소 (=일급 컬렉션)?

- 데이터의 불변을 보장하기 위해서 사용

## 운영

- 컴포넌트를 적절하게 격리하여 유지
- 컴포넌트 간 통신 방식을 특정 형태로 제한

## 개발

- 컴포넌트는 독립적으로 개발되어야함.
- 그러려면 팀별로 관심사별로 묶어 서로 방해 받지 않도록 해야한다.

## 배포

- 컴포넌트 단위의 즉각적인 배포가 가능해야한다.

## 선택사항 열어놓기

- 제곧내
    - 선택 사항(외부 관심사들의 균형)을 닫아두면 향후 시스템 변경이 어렵다.

## 계층 결합 분리

- 수직 수평으로 분리했을 때, 맨 아래 계층(데이터베이스) 까지 모두 각 계층에서 겹치지 않게해야한다.

--- 

# 5부 17장. 경계: 선 긋기

- 소프트웨어 아키텍처는 “선을 긋는 기술” 이러한 선을 **경계**라고 부른다.
- 일찍 내려진 결정(프레임워크 B B,버 ,서버 ,이브러리, 의존성)에 따른 결합에 따라 인적 자원의 효율이 떨어진다

## 결론

경계선을 그리려면 컴포넌트 단위로 분할해야한다.

---

# 5부 18장. 경계 해부학

## 경계 횡단하기

적절한 위치에서 경계를 횡단하게 하는 비결은 소스코드 의존성 관리에 있다.

> 소스코드 모듈 하나가 변경되면 의존하는 다른 소스코드 모듈도 변경하거나 다시 컴파일해서 배포해야할 수도 있기 때문이다.
> 

## 두려운 단일체

`단일체` : Monolithic

🧐 **동적 다형성 (Dynamic Polymorphism)**

- 동적 다형성은 마치 서로 다른 모양의 퍼즐 조각들을 모아서 크고 아름다운 그림을 만들어내는 것과 비슷합니다. 각 퍼즐 조각은 다양한 모양과 크기를 가지고 있지만, 모두 함께 조립하여 아름다운 그림을 만들 수 있습니다.
- ex. 동물들을 나타내는 다양한 객체(개, 고양이, 새)가 있을 때, 이 객체들을 모두 "소리를 내다"라는 행동을 할 수 있게 만들 수 있습니다. 이것은 마치 동물들이 함께 노래를 부르는 것과 비슷합니다. 이때 "소리를 내다"라는 행동은 하나의 다형적 함수로 정의되며, 각 동물 객체는 자신만의 소리를 내게 됩니다.
- 이것이 동적 다형성의 장점 중 하나인 "여러 객체의 모둠을 우아하게 처리할 수 있다"입니다.
- **추상화**를 의미

🧐 **정적 다형성 (Static Polymorphism):**

- 정적 다형성은 일종의 마법 상자를 사용하는 것과 비슷합니다. 이 상자 안에 다양한 크기와 모양의 객체를 넣을 수 있지만, 상자는 내부의 객체들을 이해하고 다룰 수 있습니다.
- ex. 숫자를 더하는 함수를 생각해보세요. 이 함수는 정수, 실수, 분수 등 다양한 숫자 데이터 형식을 처리할 수 있습니다. 마치 마법 상자에 숫자를 넣으면 상자 안에서 자동으로 올바른 방식으로 처리되는 것과 같습니다. 이것이 정적 다형성의 장점 중 하나인 "내장 데이터형의 모둠이 쉽게 구현된다"입니다.
- **오버로딩**을 의미

## 배포형 컴포넌트

- 아키턱체의 경계가 물리적으로 날 수 있는데 가장 단순한 형태는 동적 링크 라이브러리(jar 등)이다.

## 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야하는 경계가 혼합되어 있음을 의미한다.

🥲 18장 내용이 너무 추상적인 것 같다. 실제로 어떻게 해야하는지에 대해서 보단 이런게 있다 정도로만 이해하고 넘어간다.

---

## 19장. 정책과 수준

- 정책
    - 소프트웨어 시스템이란 정책을 기술한 것이다.
    - 좋은 아키텍처라면 각 컴포넌트를 연결 할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함.
    - 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계 되어야 한다.
- 수준
    - 수준(level)을 엄밀하게 정의 하자면 ‘입력과 출력까지의 거리’다.
    - 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.
    - 암호화 프로그램 예제
        - 그림 19.2 시스템의 더 나은 아키텍처를 보여주는 클래스 다이어그램
            - 암호화 정책 : 고수준
            - 입출력 : 저수준
        - 인터페이스로 둘러싸고 있는 경계를 만들고 그 인터페이스를 구현 하도록 해야 입출력의 변화가 생기더라도 암호화 정책은 영향을 받지 않기 때문에 더 나은 아키텍처이다.
        
        🧐그러려면 p242 그림 22.1 클린 아키텍처에서 인터페이스 어댑터 영역에서 인터페이스를 작성하고 그 인터페이스를 구현하는 클래스를 작성해야 하는 것으로 이해.
