# 5부 15장. 아키텍처란?

> 시스템을 구축했던 사람들이 만들어낸 시스템의 형태

그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.
그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포,운영, 유지보수 되도록 만들어진다.

> 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 함

## 개발
시스템 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 해야한다.

## 배포
소프트웨어 아키텍처는 쉽게 배포할 수 있도록 만들어야 한다. 배포 비용이 높아질 수록 시스템의 유용성이 떨어진다고 생각하자.

## 운영
시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 first-class 엔티티로 만들고, 개발자들에게 이들을 주요 목표로 인식 되도록 해야한다.

→이를 통해 시스템 이해가 쉬워진다.

## 유지보수
유지보수는 가장 비용이 많이 드는 부분이지만, 아키텍처를 신중하게 만들면 이 비용을 줄일 수 있다.

탐사와 그것으로 인한 위험요소에 대한 비용이 제일 많이 들기 때문에, 더욱 신경써야한다.

탐사 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 어디를 고쳐야 할지, 어떤 전략을 쓰는게 최적일지 판단하는 비용

>*탐사란?
> 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트 웨어를 파해쳐서 어디를 고치는게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용

## 선택사항 열어두기
소프트웨어를 부드럽게 유지하려면, 중요하지 않은 세부사항을 가능한 많이, 그리고 오랫동안 열어두는 것이다.

정책 : 시스템의 진정한 가치로서, 모든 업무 규칙과 업무 절차를 구체화한다.
세부사항 : 클라이언트, 프로그래머 등이 정책과 소통할 때, 필요한 요소지만, 정책이 가진 행위에는 영향을 미치지 않음을 유의해야한다.
→ 좋은 아키텍트는 결정되지 않는 것들의 수를 최대화 해야한다.

## 장치 독립성
장치독립적인 것을 중요하다. 장치 종속적일 경우 장치마다 해당 코드를 생성해야하기 때문이다.

오늘날 운영체제는 장치 독립적이다.

## 광고 우편
저자의 경험이 담겨있다.

정책을 세부사항으로 분리하고, 어떤장치를 사용할 지에 대한 결정을 최대한 미뤘다는 내용이 담겨있다.

## 물리적 주소할당
정책을 물리적 구조로 부터 독립시킴으로써 애플리케이션과 하드웨어를 분리할 수 있었다.

## 결론
좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.

---

# 5부 16장. 독립성

## 좋은 아키텍처

- 시스템의 유즈케이스 지원
- 시스템의 운영이 고려된 아키텍처
- 시스템의 독립적 개발
- 시스템의 즉각적인 배포

## 유즈케이스

- 시스템이 지닌 의도를 아키텍처 수준에서 알아 볼 수 있도록 만드는 것이다.
    - 🧐 MVC Model2 Architecture의 Controller 역할?

🧐 일급 요소 (=일급 컬렉션)?

- 데이터의 불변을 보장하기 위해서 사용

## 운영

- 컴포넌트를 적절하게 격리하여 유지
- 컴포넌트 간 통신 방식을 특정 형태로 제한

## 개발

- 컴포넌트는 독립적으로 개발되어야함.
- 그러려면 팀별로 관심사별로 묶어 서로 방해 받지 않도록 해야한다.

## 배포

- 컴포넌트 단위의 즉각적인 배포가 가능해야한다.

## 선택사항 열어놓기

- 제곧내
    - 선택 사항(외부 관심사들의 균형)을 닫아두면 향후 시스템 변경이 어렵다.

## 계층 결합 분리

- 수직 수평으로 분리했을 때, 맨 아래 계층(데이터베이스) 까지 모두 각 계층에서 겹치지 않게해야한다.

--- 

# 5부 17장. 경계: 선 긋기

- 소프트웨어 아키텍처는 “선을 긋는 기술” 이러한 선을 **경계**라고 부른다.
- 일찍 내려진 결정(프레임워크 B B,버 ,서버 ,이브러리, 의존성)에 따른 결합에 따라 인적 자원의 효율이 떨어진다

## 결론

경계선을 그리려면 컴포넌트 단위로 분할해야한다.

---

# 5부 18장. 경계 해부학

## 경계 횡단하기

적절한 위치에서 경계를 횡단하게 하는 비결은 소스코드 의존성 관리에 있다.

> 소스코드 모듈 하나가 변경되면 의존하는 다른 소스코드 모듈도 변경하거나 다시 컴파일해서 배포해야할 수도 있기 때문이다.
> 

## 두려운 단일체

`단일체` : Monolithic

🧐 **동적 다형성 (Dynamic Polymorphism)**

- 동적 다형성은 마치 서로 다른 모양의 퍼즐 조각들을 모아서 크고 아름다운 그림을 만들어내는 것과 비슷합니다. 각 퍼즐 조각은 다양한 모양과 크기를 가지고 있지만, 모두 함께 조립하여 아름다운 그림을 만들 수 있습니다.
- ex. 동물들을 나타내는 다양한 객체(개, 고양이, 새)가 있을 때, 이 객체들을 모두 "소리를 내다"라는 행동을 할 수 있게 만들 수 있습니다. 이것은 마치 동물들이 함께 노래를 부르는 것과 비슷합니다. 이때 "소리를 내다"라는 행동은 하나의 다형적 함수로 정의되며, 각 동물 객체는 자신만의 소리를 내게 됩니다.
- 이것이 동적 다형성의 장점 중 하나인 "여러 객체의 모둠을 우아하게 처리할 수 있다"입니다.
- **추상화**를 의미

🧐 **정적 다형성 (Static Polymorphism):**

- 정적 다형성은 일종의 마법 상자를 사용하는 것과 비슷합니다. 이 상자 안에 다양한 크기와 모양의 객체를 넣을 수 있지만, 상자는 내부의 객체들을 이해하고 다룰 수 있습니다.
- ex. 숫자를 더하는 함수를 생각해보세요. 이 함수는 정수, 실수, 분수 등 다양한 숫자 데이터 형식을 처리할 수 있습니다. 마치 마법 상자에 숫자를 넣으면 상자 안에서 자동으로 올바른 방식으로 처리되는 것과 같습니다. 이것이 정적 다형성의 장점 중 하나인 "내장 데이터형의 모둠이 쉽게 구현된다"입니다.
- **오버로딩**을 의미

## 배포형 컴포넌트

- 아키턱체의 경계가 물리적으로 날 수 있는데 가장 단순한 형태는 동적 링크 라이브러리(jar 등)이다.

## 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야하는 경계가 혼합되어 있음을 의미한다.

🥲 18장 내용이 너무 추상적인 것 같다. 실제로 어떻게 해야하는지에 대해서 보단 이런게 있다 정도로만 이해하고 넘어간다.

---

## 19장. 정책과 수준

- 정책
    - 소프트웨어 시스템이란 정책을 기술한 것이다.
    - 좋은 아키텍처라면 각 컴포넌트를 연결 할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함.
    - 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계 되어야 한다.
- 수준
    - 수준(level)을 엄밀하게 정의 하자면 ‘입력과 출력까지의 거리’다.
    - 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.
    - 암호화 프로그램 예제
        - 그림 19.2 시스템의 더 나은 아키텍처를 보여주는 클래스 다이어그램
            - 암호화 정책 : 고수준
            - 입출력 : 저수준
        - 인터페이스로 둘러싸고 있는 경계를 만들고 그 인터페이스를 구현 하도록 해야 입출력의 변화가 생기더라도 암호화 정책은 영향을 받지 않기 때문에 더 나은 아키텍처이다.
        
        🧐그러려면 p242 그림 22.1 클린 아키텍처에서 인터페이스 어댑터 영역에서 인터페이스를 작성하고 그 인터페이스를 구현하는 클래스를 작성해야 하는 것으로 이해.

---

## 5부 20장. 업무 규칙

- `업무 규칙` : 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다.
    - 핵심 업무 규칙 : 사업 자체에 핵심적 (ex. 은행 대출 이자율)
    - 핵심 업무 데이터 : 자동화되지 않은 경우에도 존재하는 데이터 (ex. 대출 잔액, 이자율, 지급 일정)

### 엔티티

- 핵심 업무 규칙을 핵심 업무 데이터로 구체화하는 시스템 내부의 객체

### 유즈케이스

- 자동화된 시스템이 사용되는 방법을 설명한다. (신규 대출)
- 유즈케이스는 어플리케이션에 특화된 업무 규칙을 설명한다.
- 유즈케이스는 사용자 인터페이스를 기술하지 않는다.
    - 어플리케이션에 특화된 규칙을 설명하고, 사용자와 엔티티 사이의 상호 작용을 규정하는데 주 목적이 있다.
- 유즈케이스는 저수준
    - 단일 어플리케이션에 특화
    - 해당 시스템의 입력과 출력에 가깝게 위치하고 있다.
- 엔티니는 고수준
    - 수많은 다양한 어플리케이션에서 사용될 수 있또록 일반화된 것
- 유즈케이스 → 엔티티 (의존)

### 요청 및 응답 모델

- 두 객체는 다른 이유로 변경될 수 있다.
- 함께 묶는 행위는 공통 폐쇄 원칙과 단일 책임 원칙을 위배한다.

---

## 5부 21장. 소리치는 아키텍처

- 잘 정의된 유즈케이스는 그 자체만으로도 아키텍처를 의미한다. (ex. 도서관)

### 아키텍처의 테마

- 부제 : 유즈케이스 주도 접근법
- 도구에 의존하여 아키텍처를 설계해선 안된다.

### 아키텍처의 목적

- `지엽적`인 관심사에 대한 결합을 분리시키고 유스케이스의 중점으로 좋은 아키텍처를 설계해서 프레임워크에 대한 선택 사항을 미룰수 있다. 이 말을 **열어 둬야할 선택사항**이다. 라고 말하고 있다.
    - `지엽적` : 본질적인 것이 아니고 부차적인 (것). 순화어는 `자질구레한'.

- 웹도 마찬가지다

### 테스트하기 쉬운 아키텍처

- 유즈케이스 전부에 대해서 **단위 테스트**를 할 수 있어야 한다.
- 프레임워크 등 의존해서는 안되고 객체 그 자체만으로도 테스트가 가능해야한다.

🤔 신규 대출 예시로 보면 신규 대출을 위한 프로세스는 비지니스 로직 그 신규 대출을 하기 위한 객체가 존재한다.

그 객체가 의미하는 값들을 전달하였을 때 비지니스 로직이 테스트가 가능해야한다.

---

## 5부 22장. 클린 아키텍처

- 지난 수 십년간 시스템 아키텍처와 관련된 여러 아이디어
    - Hexagonal Architecture(육각형 아키텍처 혹은 포트와 어댑터)
    - DCI(Data, Context, Interaction)
    - BCE(Boundary-Control-Entity)
- 목표는 **모두 계층 분리를 통한 관심사의 분리**이며 다음과 같은 특징을 지닌다.
    - 프레임워크 독립성: 프레임워크을 도구로 사용하며, 프레임워크가 지닌 제약사항으로 시스템을 강제하지 않음
    - 테스트 용이성: 업무 규칙은 UI, DB, 웹서버 및 다른 외부 요소 없이도 테스트할 수 있음
    - UI 독립성: 시스템의 나머지를 변경하지 않고도 UI를 쉽게 변경할 수 있음
    - 데이터베이스 독립성: 오라클이나 MS-SQL 서버 등을 다른 DB로 교체할 수 있고, 업무 규칙은 DB에 결합되지 않음
    - 외부 에이전시에 대한 독립성: 실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못함
    ![1](https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/635fa26f-3bbf-43e7-b965-ff493c5371a3)
    그림 22.1 클린 아키텍처
    

### 의존성 규칙

- 안쪽으로 들어갈 수록 고수준의 소프트 웨어
- 바깥족 원은 매커니즘이고, 안쪽 원은 정책이다.
- 가장 중요한 규칙은 의존성 규칙이다.

> 소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
> 

```
bank
│
├─ adapter
│  ├─ in
│  │  ├─ web          (웹 요청을 처리하는 컨트롤러 및 DTO)
│  │  └─ ui           (사용자 인터페이스를 처리하는 컴포넌트나 클래스)
│  │
│  └─ out
│     └─ persistence  (데이터베이스와의 연동을 위한 리포지토리나 DAO)
│       └─jpa 
│           └─ jpaEntity  (jpa를 사용할경우 @Entity는 여기)
│           └─ mapper    ( domain-entity 변환 mapper는 여기)
│
├─ application
│  ├─ port
│  │  ├─ in           (내부에서 사용하는 API 정의)
│  │  └─ out          (외부 시스템, 예: 데이터베이스, 다른 서비스와의 연동을 위한 인터페이스 정의)
│  │
│  └─ service         (유스케이스를 구현하는 서비스 클래스)
│
└─ domain             (도메인 모델, 엔터티, 값 객체, 도메인 서비스, 도메인 이벤트 등)
```

🤔  사이드프로젝트에 DDD와 헥사고날을 퓨전으로 적용하고 싶다.. 궁금증

[각각 쓰는지 이해 DDD와 Hexagonal](https://dataportal.kr/74)

🤔 그래서 도대체 뭘 어떻게 해야할까..?

[클린 아키텍처 패키지 구조 참고 링크](https://github.com/thombergs/buckpal)

![2](https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/6b7ec205-6828-40b6-a2e1-24a9f0205c4a)


### 엔티티

- 엔티티 계층에는 무언가가 변경이 필요하더라도 절대로 영향을 주어서는 안된다.

### 유스케이스

- 반복적으로 하는 말. 유즈케이스는 애플리케이션에 특화된 업무 규칙을 포함한다.
- 모든 유스케이스를 캡술화 하고 구현한다.
    - useCase Interface를 만들고 구현체를 따로 만들어서 코딩해야한다.

### 전형적인 시나리오
![3](https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/78d98748-08f2-4f5f-ad8f-5404ffec9895)

그림 22.2 데이터베이스를 사용하는, 웹 기반 자바 시스템의 전형적인 시나리오

## 23장 프레젠터와 험블 객체

### 험블 객체 패턴

- 험블객체패턴은 디자인 패턴으로 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
- **구현방법은 행위들을 모두 두개의 클래스로 나눈 후 테스트하기 어려운 행위를 험블 객체에 옮기고 나머지는 다른 객체에 넣는다.**

### 프레젠터와 뷰

- 뷰는 험블 객체이고 테스트하기 어렵다. 데이터를 GUI로 이동시키지만 데이털르 직접 처리하지는 않는다
- 프레젠터는 테스트하기 쉬운 객체다. 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다.
    - ex: Data 객체를 적절한 포맷의 문자열로 만드는 것

### 테스트와 아키텍처

- 테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져 왔다.
- 험블 객체 패턴이 좋은 예인데 아키텍처 경계가 정의되기 때문이다. (뷰 / 프레젠터)

### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터 베이스 사이에는 데이터베이스 게이트웨이가 위치한다.
- 데이터베이스는 험블객체이다. 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기때문에 험블 객체가 아니다. 그러므로 테스트하기 용이하다.
    - 이는 스텁(stub)이나 테스트 더블(test-double)로 적당히 교체할 수 있다.

### 데이터 매퍼

- 객체 관계 매퍼 같은건 사실 존재하지 않는다. 객체는 데이터구조가 아니기 때문이다.
- 객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이다. ORM 보다는 데이터 매퍼라고 부르는 편이 나은데 관계형 데이터 베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주기 때문이다.
- ORM 시스템은 데이터 베이스 계층에 위치해야 한다.

### 서비스 리스너

- 서비스의 경우에도 서비스 경계를 생성하는 험블 객체 패턴을 발견할 수 있다.
- 데이터 구조를 경계를 가로질러서 특정 모듈로 전달한다. 그러면 해당 모듈은 데이터를 적절한 포맷으로 만들어서 외부 서비스로 전송한다. 해당 모듈은 데이터를 적절한 포맷으로 만들어서 외부 서비스로 전송한다.

### 결론

각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다. 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리되겠다. 이로인해 테스트의 용이성을 크게 높힐 수 있다.

## 24장 부분적 경계

아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다. 비용이 너무 크다고 판단되면 부분적 경게를 구현해볼수 있다.

### 마지막 단계를 건너뛰기

- 컴파일하고 배포할 수 있는 컴포넌트를 만들고 단일 컴포넌트에 그대로 모아만 두는 것이다. 쌍방향 인터페이스도 그 컴포넌트에 있고 입력 출력 데이터. 구조도 거기에 있으며 모든것이 완전히 준비되어 있다.
- 하지만 완벽한 경계와 사전 설계가 충분히 필요하다.

### 일차원 경계

<img width="1000" alt="1" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/d7d5efdb-21d6-41f3-a681-d7769da72839">

- 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 Strategy 패턴을 사용한 전형적인 사례다.
    - ServiceBoundary 인터페이스는 클라이언트가 사용하며 ServiceInpl 클래스가 구현한다.
- 이러한 분리는 빨간 점선처럼 오용해서는 안되도록 주의가 필요하다

### 퍼사드

- 이보다 단순한 경계는 퍼사드 패턴으로 Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다.
- 클라이언트는 이들 서비스에 직접 접근할 수 없지만 Client가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.

### 결론

아키텍처 경계가 언제, 어디에 존재해야 할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역할이다.

## 25장 계층과 경계

시스템이 세가지 컴포넌트(UI, 업무 규칙, 데이터베이스)로만 구성되지는 않을 수 있다.

- 게임 규칙, 게임의 예제에서 중요한 아키텍처 경계를 정말로 모두 발견한 것일까? 예를 들어 UI에서 언어가 유일한 변경의 축은 아니고 텍스트를 주고받는 매커니즘을 다양하게 만들고 싶을 수도 있다. 이 변경의 축에 의해 정의되는 아키텍처 경계가 잠재되어 있을 수 있다.

### 흐름 분리하기

- 항상 상단의 단일 컴포넌트에서 서로 만나지는 않는다.
- 이보다 더 높은 수준에는 또다른 정책 집합이 존재하는데 이는 여러 경우의 시나리오를 간략하해 묘사하면 아키텍처의 경계를 발견할 수 있다.

### 결론

- 아키텍처 경계가 어디에나 존재한다. 우리는 경계가 언제 필요한지를 신중하게 파악하면 된다.
- 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 것도 알아야한다.
    - 하지만 무시한다면 다시 추가하는 비용이 더 커진다.
- YAGNI(You Aren't Going to Need It). 오버엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다.
- 다른 한편으로는 어떤 아키텍처 경계도 존재하지 않는 상황에서 경계가 정말로 필요하다는 사실을 발견한 후 그때서야 경계를 추가하려면 비용이 많이 들고 큰 위함을 감수해야 한다.
- 목표를 달성하려면 빈틈없이 지켜봐야 한다.

## 26장 메인(Main) 컴포넌트

모든 시스템에는 최소한 하나의 컴포넌트가 존재하고 이 컴포넌트가 나머지 컴포넌트를 생성하고 조정하며 관리한다. 이것을 메인(Main) 컴포넌트라 부른다.

### 궁극적인 세부사항

- 메인 컴포넌트는 궁극적인 세부사항으로 **가장 낮은 수준의 정책이다**. 메인은 시스템의 초기 진입점이다.
- 메인은 모든 팩토리와 전략, 그리고 시스템 전반을 담당하는 나머지 기반 설비를 생성한 후 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할을 맡는다.
- 의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 바로 이 메인 컴포넌트에서 이뤄져야 한다. (???)
- **메인은 클린 아키텍처에서 가장 바깥 원에 위치하는 지저분한 저수준 모듈이라는 점이다.**
    - 메인은 고수준의 시스템을 위한 모든것을 로드한 후 제어권을 고수준의 시스템에게 넘긴다.
- 메인을 애플리케이션의 플러그인이라고 생각하자
    - 메인을 플러그인 컴포넌트로 여기고, 그래서 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.

## 27장 ‘크고 작은 모든’ 서비스들

- 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.
    - 단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고는 볼 수 없다.
- 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다. 아키텍처적으로 중요한 서비스도 있지만, 중요하지 않은 서비스도 존재한다. 이 장에서는 전자인 관점에서 본다.

### 서비스의 이점

### 결합 분리의 오류

- 큰 이점 하나는 서비스 사이의 결합이 확실히 분리된다는 점이다. 대신 서비스는 서로 다른 프로세스에서, 직접 변수에 접근할 수 없고, 인터페이스는 잘 정의되어있어야 한다.
    - 하지만 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합 될 가능성이 여전히 존재한다.

### 개발 및 배포 독립성의 오류

- 서비스를 사용함에 따라서 갖는 이점 중 또 하나는 전담팀에서 각 서비스를 작성하고 유지보수하며 운영하는 책임을 질 수 있다.
    - 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.
    - 하지만 극히 일부이다.
        - 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 이외에도 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다는 사실은 역사적으로 증명되어왔다.
        - 데이터나 행위에서 어느정도 결합되어있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다.

### 야옹이 문제

이전 9장 택시 통합 시스템 예시를 다시 가지고와서 확장 가능한시스템을 구축하고싶었기에 수많은 작은 마이크로 서비스를 기반으로 구축하기로 결정했다.
<img width="1000" alt="2" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/2513e44a-68c8-4204-87f3-9efc04a4db45">

- 이 서비스 다이어그램대로 서비스를 운영하다가 야옹이 서비스를 시작한다면 택시 업체 한곳이 추가로 들어가고 세부적인 필터를 적용해 배차를 해야한다는 등 추가, 변경 기능이 있게 된다면 거의 전부를 변경해야 한다.
    - 다시말해 이 서비스들은 모두 결합되어 있어서 독립적으로 개발하고 배포하거나 유지될 수 없다.
    - 이게 바로 횡단 관심사가 지닌 문제다. 모든 소프트웨어 시스템은 서비스 지향이든 아니든 이 문제에 직면하게 마련이다.
    - 이렇게 묘사괸것과 같은 종류의 기능적 분해는 새로운 기능이 기능적 행위를 횡당하는 상황에 매우 취약하다

### 객체가 구출하다

- 컴포넌트 기반 아키텍처에서는 SOLID 설계 원칙을 적용하는데, 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함을 알 수 있다
<img width="1000" alt="3" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/30034a83-832a-46fc-8bb2-7c17b841b22d">


- 경계와 의존성 규칙을 준수하는것을 볼 수 있다.
- Rides / Kittens 컴포넌트로 나누고 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용해서 오버라이드 한다.
- 이 전략을 따르더라도 야옹이 기능을 구현하려면 TaxiUI는 어쩔수 없이 변경해야만 하지만 그 외의 것들은 변경할 필요가 없다.
- 즉 야옹이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있다.

### 컴포넌트 기반 서비스

- 서비스에도 컴포넌트 기반 서비스를 만들수 있다. 서비스가 소규모 단일체일 필요는 없다.
<img width="1000" alt="4" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/c0191cd0-0265-4220-9a33-b19549c4ec87">

- 이전 예에 이어가면서 서비스들의 존재는 이전과 달라진게 없지만 각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다. 파생 클래스들은 각자의 컴포넌트 내부에 놓인다.

### 횡단 관심사
<img width="1000" alt="5" src="https://github.com/dev-wooyeon/reading-books-for-programmers/assets/50124623/f59ca575-d81c-45e0-ae62-e7ceee544568">

- 아키텍처 경계가 서비스 사이에 있지 않다는 사실이다. **오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.**
- 횡단 관심사를 처리하려면 아래 다이어그램에서 보듯이, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
- 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트다.

### 결론

- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.
- 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.
