## 항목 1: @OneToMany 연관관계를 효과적으로 구성하는 방법

### 항상 부모 측에서 자식 측으로 전이를 사용

```java
@OneToMany(cascade=CascadeType.ALL)
```

- 부모 객체가 변경되었을 때 자식 객체에도 해당 변경 사항을 전파할지 여부를 설정할 수 있습니다.
- **`CascadeType.ALL`**은 다음과 같은 작업에 대해 전파됩니다.
    - **`PERSIST`**: 부모 객체가 영구 저장될 때 자식 객체도 함께 저장됩니다.
    - **`REMOVE`**: 부모 객체가 삭제될 때 자식 객체도 함께 삭제됩니다.
    - **`REFRESH`**: 부모 객체가 새로고침될 때 자식 객체도 함께 새로 고쳐집니다.
    - **`MERGE`**: 부모 객체가 병합될 때 자식 객체도 함께 병합됩니다.
    - **`DETACH`**: 부모 객체가 분리될 때 자식 객체도 함께 분리됩니다.

### 부모 측에 mappedBy지정

- mappedBy 속성은 양방향 연관관계의 특성을 부여한다.
- 부모측에는 @OneToMany mappedBy가 지정되고 mappedBy에 의해 참조되는 자식 측에는 @ManyToOne이 지정된다.
- mappedBy는 양방향 연관관계 매핑을 미러링한다는 신호를 보내는 것

```java
@OneToMany(cascade=CascadeType.ALL, mappedBy="author")
```

### 부모 측에 orphanRemoval 지정

- 더 이상 참조되지 않는 자식들의 삭제를 보장한다.
- 소유 객체로부터 참조 없이 존재할 수 없는 의존 객체를 정리하기에 유용하다.

```java
@OneToMany(cascade=CascadeType.ALL, mappedBy="author", orphanRemoval=true)
```

- 🤔 이건 참조를 끊을 때 데이터베이스에서 데이터를 지우게 되는데 현업에서는 사용하기 어려울 것 같다..?
물론 참조되지 않는 자식들이라면 서비스 운영에는 지장없겠지만 히스토리를 찾을 수 없기 때문에 사용하지 않을것이다..

### 연관관계의 양측을 동기화 상태로 유지

- 유지하지 않으면 객체의 상태 전환으로 인해 예기치 않은 동작이 발생될 수 있음으로 도우미 메소드를 통해 연관관계의 양쪽 상태를 동기화 한다.

### equals()와 hashCode() 오버라이딩

- 이거 오버라이딩하면 모든 엔티티가 상태 전환에서 동일한 결과를 얻을 수 있다. -동등성 검사
- 🤔 이건 대체 언제 써야하는걸까..?
동일한 이름과 이메일을 가진 두 사용자가 있을 때 이 두명이 동일한 사용자인지 확인 할 때 사용할 수 있을 것 같다.

### 연관관계 양측에서 지연 로딩 사용

- 부모 측 객체를 가지고 올 때 자식 측 객체는 가져오려면 자식 객체에서 명시적으로 LAZY로 지정하면 된다.

```java
@ManyToOne(fetch = FetchType.LAZY)
```

### toString() 오버라이딩 방법에 주의

- 부모 객체에서 자식 컬렉션을 사용하지 말고 부모 객체의 기본 속성만 사용해야한다.
- 이걸 지키지 않으면 자식의 데이터를 가져오는 별도 SQL문이 실행되거나 LazyInitailizationException이 발생되기 때문이다.

### @JoinColumn을 사용해 조인 컬럼 지정

- 조인 컬럼을 지정할 때 명시적으로 의도된 이름을 사용하는 것이 혼동이나 실수를 피할 수 있기 때문에 좋다.
- 이거 아무렇게나 짓는게 아니라 데이터베이스 내에서 연관관계를 가지는 부모 객체의 외래 키의 이름을 지정하는 거임!
- 한마디로 연관관계를 가지는 테이블 컬럼을 만들 때 외래 키는 명시적으로 의도된 이름을 사용해야 한다는 것

## 항목 2: 단방향 @OneToMany 연관관계를 피해야 하는 이유
- 이 항목에서 결론적으로 말하고자 하는 것은 양방향 연관관계를 가질 때 보다 처리해야하는 데이터들이 더 많아 효율적이지 않기 때문에 피해야한다고 말하고 있다.
- 연관관계를 가지는 테이블이 생성되어야하기 때문이다.

## 항목 3: 단방향 @ManyToOne 효율성
- 항목2와 반대로 이건 효율적이다.
- '왜?' 일까?
- 양방향과 동일한 매커니즘으로 작동하며 항목 2에서 발생하는 비효율적인 연산을 하지 않기 때문이다.
- 예시로 저자의 모든 도서를 가지고 오는 쿼리가 있다고 할 때 하나의 select만 필요하기 때문이다.
- 가져온 컬렉션에서 도서를 삭제하는 경우에도 하나의 delete문을 통해 삭제가 되기 때문이다.
- 양방향 @OneToMany 연관관계가 필요하지 않을 때 사용하면 될 듯 싶다.

## 항목 4: @ManyToMany 연관관계를 효율적으로 구성하는 방법
## Todo. 여기서 부터 이어서 진행