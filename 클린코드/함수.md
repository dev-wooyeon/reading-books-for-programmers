# 함수

### 1. 작게 만들어라!

- 함수를 만드는 규칙은 첫째도 둘째도 작게!
- 함수별로 라인수를 적게하라.
- 명백한 함수의 기능은 라인수도 적어질수있다.
- 블록과 들여쓰기
    - if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다.
    - 중첩 구조가 생길만큼 함수가 커져서는 안된다.
    - 함수에서 들여쓰기 수준은 1단 혹은 2단을 넘어서는 안된다.

### 2. 한 가지만 해라!

- “함수는 한가지를 해야 한다. 그 한가지를 잘 해야 한다. 그 한 가지만을 해야한다.”
- 하나의 함수에는 하나의 기능만해야한다.
- 정확히 말하자면 함수 아래에서 추상화 수준이 하나여야 한다.
- ex) 버퍼를 생성하고, 페이지를 가져오고, 상속된 페이지를 검색하고, 경로를 렌더링하고, 문자열 붙이고, HTML 생성한다. → 한 가지 이상을 하는 함수
- ex) 페이지가 테스트 페이지인지 판단하고, 페이지를 HTML로 렌더링한다. → 한 가지만 하는 함수

### 3. 함수 당 추상화 수준은 하나로!

- 함수가 한 가지의 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다.
- 이렇게 다른 수준의 추상화를 동시에 사용하면 읽는 사람이 헷갈린다.
- 위에서 아래로 코드 읽기: 내려가기 규칙
    - 코드는 위에서 아래로 이야기처럼 읽혀야 좋은 코드이다.
    - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
    - 즉, 위에서 아래로 읽으면서 함수 추상화 수준이 한번에 한 단계씩 낮아진다.

### 4. Switch 문

- switch 문은 작게 만들기 어렵다. N가지를 처리하기 때문.
- 완전히 피할 방법은 없지만 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다.
- 다형성을 이용
- switch문은 최대한 사용하지 마라.

### 5. 서술적인 이름을 사용하라!

- 이름이 길어도 괜찮다, 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
- 함수가 작고 단순할수록 서술적인 이름을 고르기 쉬워진다.
- 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
- 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.
- 이름을 정하느라 시간을 들여도 괜찮다.
- 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기도 쉬워진다.
- 이름을 붙일 떄는 일관성이 있어야 한다.
    - ex) includeSetupAndTeardownPages, includeSetupPages, includeSuiteSetupPage

### 6. 함수 인수

- 함수에서 이상적인 인수 개수는 0개.
- 다음은 1개, 다음은 2개.
- 3개는 가능한 피하는 편이 좋다.
- 4개 이상은 사용하지 마라.
- 테스트 관점에서 생각하면 인수가 없을 수록 간단하다.
- 최선은 입력 인수가 없는 경우이고, 차선은 입력 인수가 1개뿐인것.
    - ex) includeSetupPageInto(newPageContent)보다 includeSetupPage()가 더 이해하기 쉽다.
    - 읽는 사람이 현 시점에서 별로 중요하지 않은 세부사항인 세부사항까지 알아야한다.
- 많이 쓰는 단항 형식
    - 함수에 인수 1개를 넘기는 이유로 가장 흔한 경우
        - 인수에 질문을 던지는 경우
            - boolean fileExists(“MyFile”)이 좋은 예
        - 인수를 뭔가로 변환해 결과를 변환하는 경우
            - InputStream fileOpen(“MyFile”)은 String 형의 파일 이름을 InputStream으로 변환한다.
        - 이벤트 함수
            - 이벤트 함수는 입력 인수만 있고 출력 인수는 없다.
            - 이벤트라는 사실이 코드에 명확히 드러나야 한다.
            - 이름과 문맥을 주의해서 선택한다.
    - 이러한 경우가 아니라면 단항 함수는 가급적 피한다.
        - ex) void includeSetupPageInfo(StringBuffer pageText)는 피한다.
        - 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.
        - 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.
            - ex) StringBuffer transform(StringBuffer in)이 void transform(StringBuffer out)보다 좋다.
- 플래그 인수
    - 함수로 Boolean 값을 넘기것은 하지마라.
    - 함수가 한꺼번에 여러 가지를 처리한다고 공표하는 셈.
- 이항 함수
    - wirteField(name)은 writeField(outputStream, name)보다 이해하기 쉽다.
    - 이항 함수가 적절한 경우도 있다.
        - ex) Point p = new Point(0, 0);
    - assertEquals(expected, actual)로 했을때, expected자리에 actual을 넣고 actual자리에 expected를 넣는 실수가 있을 수 있다.
    - 이항 함수가 무조건 나쁘다는 것은 아니고, 불가피한 경우가 생길 수 있다.
    - 단항 함수로 바꾸도록 애써라.
- 삼항 함수
    - 삼항 함수를 만들 때는 신중하게 고려하라고 권고한다.
    - assertEquals(message, expected, actual)이라는 함수가 있을때, expected가 첫인수라고 예상했는데 message에 뭐가 들어가야하는지 확인해봐야한다.
- 인수 객체
    - 인수가 2~3개 필요하다면 독자적인 클래스 변수로 선언할 가능성을 짚어봐라.
    - ex) Circle makeCircle(double x, double y, double radius);
    - → Circle makeCircle(Point center, double radius);
    - 눈속임이라 여겨질 수 있지만 개념만 표현하면 된다.
- 인수 목록
    - 인수 개수가 가변적인 함수도 필요하다.
    - 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다. (삼항을 넘기면 문제가 있다.)
    - void monad(Integer… args);
    - void dyad(String name, Integer… args);
    - void triad(String name, int count, Integer… args);
    - 매개변수로 배열을 넘겨주는 경우에는 매개변수를 생략할 수 없기 때문에 배열의 크기가 0인 변수를 매개변수를 넣어주거나, null 값을 넘겨주어야 한다. 하지만 가변인자를 사용하면 매개변수를 생략해야 하는 경우 생략이 가능하다. 이 차이점으로 인해 가변인자가 사용되는 것 같다.

### 7. 부수 효과를 일으키지 마라!

- ex) 비밀번호를 체킹하는 checkPassword라는 함수를 만들어두고 그안에 Session.initialize()호출을 넣지마라.
- 그럼 사고가 발생한다.
- 하나의 함수는 하나의 기능을 수행해야한다를 잊지마라.
- 만약 결합이 필요하다면 함수 이름에 분명히 명시하라.
    - checkPasswordAndInitializeSession
- 출력 인수
    - 일반적으로 인수를 함수 입력으로 해석.
    - appendFooter(s);
        - s를 바닥글로 첨부? s에 바닥글을 첨부?
        - s는 입력일까 출력일까
        - 함수 선언부를 찾아봐야 알 수있다. (이는 코드를 보다가 주춤하는 행위와 동급)
    - 인지적으로 거슬리는 것은 피해야한다.
    - report.appendFooter()로 사용하는 방식이 좋은 방식.

### 8. 명령과 조회를 분리하라!

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.
- 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나만.
- ex) public boolean set(String attribute, String value);
- 이 함수는 이름이 attribute인 속성을 찾아 value로 설정한 후 성공하면 true, 실패하면 false를 반환.
- if( set(“username”, “pty”))…
- if문에 있으면.. “username” 속성이 “pty”로 설정되어 있다면으로 읽힐 것이다..
- set을 setAndCheckIfExists라고 바꾸는 방법도 있지만 if 문에 넣고보면 어색하다.
- 해결책은 명령과 조회를 분리해 혼란을 초기에 뿌리뽑는 방법.
    - if (attributeExists(“username”)) {
    - setAttribute(“username”, “pty”);

### 9. 오류 코드보다 예외를 사용하라!

- if/else로 else에 오류 났을때 처리하지말고 try/catch를 사용하라.
- try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.
- try일땐 deletePage(page); catch일땐 logError(e);
- 오류 처리도 한 가지 작업이다.
    - 오류를 처리하는 함수는 오류만 처리해야 한다.

### 10. 반복하지 마라!

- 중복된 코드를 제거하라.

### 11. 구조적 프로그래밍

- 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.
- 즉, 함수는 return 문이 하나여야 한다.
- 함수를 작게 만들면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다.
- 오히려 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.
- goto문은 큰 함수에서만 의미가 있으므로, 작은 함수에서는 피해야 한다.

>> 자바는 goto 없음.

### 12. 함수를 어떻게 짜죠?

- 글짓기와 비슷하다.
- 먼저 생각을 기록한 후 읽기 좋게 다듬는다와 비슷하다.

---

# **[정리]**

- 함수는 하나의 기능만 수행하도록 최대한 짧게 구현하라.
- 조건문, 반복문은 하나의 함수에 하나만 사용하라.
- 함수 하나는 하나의 추상화만.
- switch문은 피하자.
- 함수이름은 짧으면 좋기는 하지만 짧은 함수이름으로 설명이 되지 않는다면 서술적인 이름을 사용하여 읽는사람이 이해하기 좋도록 해라.
- 함수 인수는 적을 수록 좋다.
- 함수의 인수로 boolean은 넘기지마라.
- 매개변수를 생략해야 하는 경우가 있을때, 동적으로 사용해야하는 것은 삼항 이하로 가변함수를 사용하라.
- 명령과 조회를 분리해서 사용해라 (위의 예시 참고)
- try/catch를 사용해라.
- 중복된 코드는 제거하라.
- return, braek, continue를 여러차례 사용해서 의도를 표현하기 쉽게하도록 함수를 작게 만들어라.
- 일단 구현해두고 끝이아니라 잘 다듬고 이해하기 쉽도록 다듬어라.